{"version":3,"sources":["../../source/Search.js"],"names":["Search","uidFieldName","Error","_uidFieldName","_indexStrategy","_searchIndex","_sanitizer","_tokenizer","_documents","_searchableFields","document","addDocuments","documents","concat","indexDocuments_","field","push","query","tokens","tokenize","sanitize","search","doc","uid","fieldValue","_initialized","indexStrategy","sanitizer","searchIndex","tokenizer","toString","fieldTokens","fti","numFieldValues","length","fieldToken","expandedTokens","expandToken","eti","nummExpandedTokens","expandedToken","indexDocument","di","numDocuments","Array","sfi","numSearchableFields","fieldValues","searchableField","i","indexDocumentsValue_","value"],"mappings":"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","file":"Search.js","sourcesContent":["// @flow\nimport getNestedFieldValue from './getNestedFieldValue';\nimport getNestedFieldValues from './getNestedFieldValues';\n\nimport { PrefixIndexStrategy } from './IndexStrategy/index';\nimport { LowerCaseSanitizer } from './Sanitizer/index';\nimport { TfIdfSearchIndex } from './SearchIndex/index';\nimport { SimpleTokenizer } from './Tokenizer/index';\n\nimport type { IIndexStrategy } from './IndexStrategy/index';\nimport type { ISanitizer } from './Sanitizer/index';\nimport type { ISearchIndex } from './SearchIndex/index';\nimport type { ITokenizer } from './Tokenizer/index';\n\n/**\n * Simple client-side searching within a set of documents.\n *\n * <p>Documents can be searched by any number of fields. Indexing and search strategies are highly customizable.\n */\nexport class Search {\n\n  _documents : Array<Object>;\n  _indexStrategy : IIndexStrategy;\n  _initialized : boolean;\n  _sanitizer : ISanitizer;\n\n  /**\n   * Array containing either a property name or a path (list of property names) to a nested value\n   */\n  _searchableFields : Array<string|Array<string>>;\n\n  _searchIndex : ISearchIndex;\n  _tokenizer : ITokenizer;\n  _uidFieldName : string | Array<string>;\n\n  /**\n   * Constructor.\n   * @param uidFieldName Field containing values that uniquely identify search documents; this field's values are used\n   *                     to ensure that a search result set does not contain duplicate objects.\n   */\n  constructor(uidFieldName : string | Array<string>) {\n    if (!uidFieldName) {\n      throw Error('js-search requires a uid field name constructor parameter');\n    }\n\n    this._uidFieldName = uidFieldName;\n\n    // Set default/recommended strategies\n    this._indexStrategy = new PrefixIndexStrategy();\n    this._searchIndex = new TfIdfSearchIndex(uidFieldName);\n    this._sanitizer = new LowerCaseSanitizer();\n    this._tokenizer = new SimpleTokenizer();\n\n    this._documents = [];\n    this._searchableFields = [];\n  }\n\n  /**\n   * Override the default index strategy.\n   * @param value Custom index strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n  set indexStrategy(value : IIndexStrategy) {\n    if (this._initialized) {\n      throw Error('IIndexStrategy cannot be set after initialization');\n    }\n\n    this._indexStrategy = value;\n  }\n\n  get indexStrategy() : IIndexStrategy {\n    return this._indexStrategy;\n  }\n\n  /**\n   * Override the default text sanitizing strategy.\n   * @param value Custom text sanitizing strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n  set sanitizer(value : ISanitizer) {\n    if (this._initialized) {\n      throw Error('ISanitizer cannot be set after initialization');\n    }\n\n    this._sanitizer = value;\n  }\n  get sanitizer() : ISanitizer {\n    return this._sanitizer;\n  }\n\n  /**\n   * Override the default search index strategy.\n   * @param value Custom search index strategy\n   * @throws Error if documents have already been indexed\n   */\n  set searchIndex(value : ISearchIndex) {\n    if (this._initialized) {\n      throw Error('ISearchIndex cannot be set after initialization');\n    }\n\n    this._searchIndex = value;\n  }\n  get searchIndex() : ISearchIndex {\n    return this._searchIndex;\n  }\n\n  /**\n   * Override the default text tokenizing strategy.\n   * @param value Custom text tokenizing strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n  set tokenizer(value : ITokenizer) {\n    if (this._initialized) {\n      throw Error('ITokenizer cannot be set after initialization');\n    }\n\n    this._tokenizer = value;\n  }\n  get tokenizer() : ITokenizer {\n    return this._tokenizer;\n  }\n\n  /**\n   * Add a searchable document to the index. Document will automatically be indexed for search.\n   * @param document\n   */\n  addDocument(document : Object) : void {\n    this.addDocuments([document]);\n  }\n\n  /**\n   * Adds searchable documents to the index. Documents will automatically be indexed for search.\n   * @param document\n   */\n  addDocuments(documents : Array<Object>) : void {\n    this._documents = this._documents.concat(documents);\n    this.indexDocuments_(documents, this._searchableFields);\n  }\n\n  /**\n   * Add a new searchable field to the index. Existing documents will automatically be indexed using this new field.\n   *\n   * @param field Searchable field or field path. Pass a string to index a top-level field and an array of strings for nested fields.\n   */\n  addIndex(field : string|Array<string>) {\n    this._searchableFields.push(field);\n    this.indexDocuments_(this._documents, [field]);\n  }\n\n  /**\n   * Search all documents for ones matching the specified query text.\n   * @param query\n   * @returns {Array<Object>}\n   */\n  search(query : string) : Array<Object> {\n    var tokens : Array<string> = this._tokenizer.tokenize(this._sanitizer.sanitize(query));\n\n    return this._searchIndex.search(tokens, this._documents);\n  }\n\n    /**\n   * @param doc\n   * @param fieldValue Value to index\n   * @private\n   */\n  indexDocumentsValue_(doc : Object, uid : string, fieldValue : string) : void {\n    this._initialized = true;\n\n    var indexStrategy = this._indexStrategy;\n    var sanitizer = this._sanitizer;\n    var searchIndex = this._searchIndex;\n    var tokenizer = this._tokenizer;\n    var uidFieldName = this._uidFieldName;\n\n    if (\n      fieldValue != null &&\n      typeof fieldValue !== 'string' &&\n      fieldValue.toString\n    ) {\n      fieldValue = fieldValue.toString();\n    }\n\n    if (typeof fieldValue === 'string') {\n      var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));\n\n      for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {\n        var fieldToken = fieldTokens[fti];\n        var expandedTokens = indexStrategy.expandToken(fieldToken);\n\n        for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {\n          var expandedToken = expandedTokens[eti];\n\n          searchIndex.indexDocument(expandedToken, uid, doc);\n        }\n      }\n    }\n  }\n\n  /**\n   * @param documents\n   * @param _searchableFields Array containing property names and paths (lists of property names) to nested values\n   * @private\n   */\n  indexDocuments_(documents : Array<Object>, _searchableFields : Array<string|Array<string>>) : void {\n    this._initialized = true;\n\n    var indexStrategy = this._indexStrategy;\n    var sanitizer = this._sanitizer;\n    var searchIndex = this._searchIndex;\n    var tokenizer = this._tokenizer;\n    var uidFieldName = this._uidFieldName;\n\n    for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {\n      var doc = documents[di];\n      var uid;\n\n      if (uidFieldName instanceof Array) {\n        uid = getNestedFieldValue(doc, uidFieldName);\n      } else {\n        uid = doc[uidFieldName];\n      }\n\n      for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {\n        var fieldValue, fieldValues;\n        var searchableField = _searchableFields[sfi];\n\n        if (searchableField instanceof Array) {\n          fieldValues = getNestedFieldValues(doc, searchableField);\n          for (var i = 0; i < fieldValues.length; i++) {\n            this.indexDocumentsValue_(doc, uid, fieldValues[i]);\n          }\n        } else {\n          fieldValue = doc[searchableField];\n          this.indexDocumentsValue_(doc, uid, fieldValue);\n        }\n      }\n    }\n  }\n}\n"]}